import fetch from 'node-fetch';
import fs from 'fs';
import path from 'path';

const fetchURL = 'https://www.unpkg.com/web-features@latest/index.json';

async function generateData() {
  try {
    // 1. Fetch the URL
    const response = await fetch(fetchURL);
    if (!response.ok) {
      throw new Error('Network response was not ok ' + response.statusText);
    }

    // 2. Convert the response to JSON
    const data = await response.json();

    // 3. Function to recursively process the data
    const baselineGroups = {};

    function processFeature(feature) {
      if (feature && typeof feature === 'object') {
        if (feature.status && feature.status.baseline) {
          const baselineStatus = feature.status.baseline || 'unknown';
          if (!baselineGroups[baselineStatus]) {
            baselineGroups[baselineStatus] = [];
          }
          baselineGroups[baselineStatus].push(feature);
        } else {
          for (const key in feature) {
            if (feature.hasOwnProperty(key)) {
              processFeature(feature[key]);
            }
          }
        }
      }
    }

    // Process the root object
    processFeature(data);

    // Ensure the "src/data" directory exists
    const dataDir = path.join(process.cwd(), 'src/data');
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }

    // 4. Create one file for each possible baseline status
    for (const baselineStatus in baselineGroups) {
      const filename = path.join(dataDir, `${baselineStatus}.json`);
      const fileContent = JSON.stringify(baselineGroups[baselineStatus], null, 2);

      // 5. Write the files to disk
      fs.writeFileSync(filename, fileContent, 'utf8');
      console.log(`File written: ${filename}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

// Run the function to generate the data files
generateData();
